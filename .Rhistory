filter(Strike<=symbol_price) %>%
mutate(Return = round(Return * 100, 2))
require(scales)
gg1 = ggplot(data=profit_for_targets, aes(x=Target, y=Strike, fill=Return)) + geom_tile() +
geom_text(aes(label=Return), size=3) +
scale_fill_gradient2(low = "white", high = "green", mid = "white")
require(plotly)
ggplotly(gg1)
shiny::runApp('GitHub/OptionForTarget')
runApp('GitHub/OptionForTarget')
runApp('GitHub/OptionForTarget')
gg
gg = ggplot(data=profit_for_strike, aes(x=Strike, y=Profit), color='red') + geom_point()
gg
gg + geom_vline(xintercept = symbol_price, show.legend = T) +
geom_text(aes(label=Return))
gg + geom_vline(xintercept = symbol_price, show.legend = T) +
geom_text(aes(label=paste0(round(Return, 2),"%" ) ), size=3)
gg + geom_vline(xintercept = symbol_price, show.legend = T) +
geom_text(aes(label=paste0(round(Return*100, 2),"%" ) ), size=3)
gg + geom_vline(xintercept = symbol_price, show.legend = T) +
geom_text(aes(label=paste0(round(Return*100, 2),"%" ), vjust=1 ), size=3)
gg + geom_vline(xintercept = symbol_price, show.legend = T) +
geom_text(aes(label=paste0(round(Return*100, 2),"%" ), vjust=-1, hjust=1 ), size=3)
gg = ggplot(data=profit_for_strike, aes(x=Strike, y=Return), color='red') + geom_point()
gg + geom_vline(xintercept = symbol_price, show.legend = T) +
geom_text(aes(label=paste0(round(Return*100, 2),"%" ), vjust=-1, hjust=1 ), size=3)
gg + geom_vline(xintercept = symbol_price, show.legend = T) +
geom_text(data = profit_for_strike %>% filter(Return>0.04),aes(label=paste0(round(Return*100, 2),"%" ), vjust=-1, hjust=1 ), size=3)
ggplotly(gg1)
expand.grid(c(1,2,3), c(5,6,7))
combn(c(1,2,3))
combn(c(1,2,3), 2)
combn(c(1,2,3), 3)
outer(c(1,2,3), c(5,6,7) )
outer(c(1,2,3), c(5,6,7), FUN="+" )
outer(c(1,2,3), c(5,6,7), FUN="-" )
xx = outer(c(1,2,3), c(5,6,7), FUN="-" )
names(xx)
xx = outer(c(1,2,3), c(5,6), FUN="-" )
xx
names(xx) = c(5,6)
xx
row.names(xx)
colnames(xx)
row.names(xx) = c(1,2,3)
xx
colnames(xx) = c(5,6)
xx
xx[xx < -5]
xx[xx <0]
names(xx)=NULL
xx
xx[xx <0]
as.data.frame(xx)
xx = as.data.frame(xx)
xx[xx <0]
xx[xx <0, drop=F]
xx[xx<0]
xx[xx<0,]
xx
xx[xx<0,]
xx[xx[]<0,]
xx[xx<0,]
xx[xx<0]
xx[, xx<0]
xx[xx<0, ]
xx[xx==-4, ]
xx[xx==-4]=0
xx
expand.grid(c(1,2,3), c(5,6,7))
combn(c(1,2,3), 2)
library("tidyr", lib.loc="C:/Program Files/R/R-3.4.2/library")
yy = data.frame(a=c(1,2,3), b=c(10,13,27))
yy
outer(yy$b, FUN="-")
outer(yy$b, yy$b, FUN="-")
outer(yy$b, yy$b, FUN=sum)
outer(yy$b, yy$b, FUN="sum")
combn(c(1,2,3), 2)
t(combn(c(1,2,3), 2)
t(combn(c(1,2,3), 2))
t(combn(c(1,2,3), 2))
require(dplyr)
yy
ns = c(1:3)
combn(yy)
combn(yy, 2)
expand.grid(c(1,2,3), c(5,6,7))
expand.grid(c(1,2,3), yy)
t(combn(c(1,2,3), 2))
yy = data.frame(a=c(10,11,12,13), b=c(0.1,0.2,0.3,0.4))
yy
length(yy)
nrow(yy)
n_s = c(1:length(yy)) %>% combn(2) %>% t
n_s
c(1:length(yy))
n_s = c(1:nrow(yy)) %>% combn(2) %>% t
n_s
n_s = c(1:nrow(yy)) %>% combn(2) %>% t %>% as.data.frame
n_s
yy[n_s$V1]
n_s$V1
yy[n_s$V1,]
strikes_buy = rbind(yy[n_s$V1,], yy[n_s$V2,]
)
strikes_buy
cbind(yy[n_s$V1,], yy[n_s$V2,])
yy = data.frame(Strike=c(10,11,12,13), Premium=c(0.1,0.2,0.3,0.4))
yy
board = data.frame(Strike=c(10,11,12,13), Premium=c(0.1,0.2,0.3,0.4))
board
n_s = c(1:nrow(board)) %>% combn(2) %>% t %>% as.data.frame
n_s
cbind(board[n_s$V1,], board[n_s$V2,])
cbind(board[n_s$V1,], board[n_s$V2,], deparse.level=1)
cbind(board[n_s$V1,], board[n_s$V2,], deparse.level=2)
bind_cols(board[n_s$V1,], board[n_s$V2,])
bind_cols(board[n_s$V1,], board[n_s$V2,], id=c(1,2))
bind_cols(board[n_s$V1,], board[n_s$V2,], id=1)
board_comb = bind_cols(board[n_s$V1,], board[n_s$V2,])
board_comb %>% desc(Strike)
board_comb %>% arrange(Strike) %>% desc()
board_comb %>% arrange(desc(Strike))
board_comb
board %>% arrange(desc(Strike))
board = board %>% arrange(desc(Strike))
board_comb = bind_cols(board[n_s$V1,], board[n_s$V2,])
board_comb
board = data.frame(Strike=c(13,12,11,10), Premium=c(0.1,0.2,0.3,0.4))
board = board %>% arrange(desc(Strike))
n_s = c(1:nrow(yy)) %>% combn(2) %>% t %>% as.data.frame
bind_cols(board[n_s$V1,], board[n_s$V2,])
board = board %>% arrange(Strike)
bind_cols(board[n_s$V1,], board[n_s$V2,])
#UTF-8
if(!require('quantmod')) install.packages('quantmod')
getOptionChain('QQQ')
library("fOptions", lib.loc="C:/Program Files/R/R-3.4.2/library")
xboard = getOptionChain('QQQ', 2018-07-15)
xboard = getOptionChain('QQQ', '2018-07-15')
xboard = getOptionChain('QQQ', '2018-06-15')
xboard
xopt = xboard$calls %>% select(Strike=164)
xopt = xboard$calls %>% filter(Strike=164)
xopt = xboard$calls %>% filter(Strike==164)
board$calls
xboard$calls
xopt = xboard$calls %>% filter(Strike==164)
xopt = xboard$calls %>% as.data.frame %>% filter(Strike==164)
xcalls = xboard$calls
xcalls %>% filter(Strike==164)
xcalls %>% filter(Strike == 164)
xcalls$Strike
xcalls$Strike %>% str
xcalls$Strike %>% class
xcalls %>% as.tbl
xcalls %>% filter(Strike == 164)
xcalls %>% as.tbl%>% filter(Strike == 164)
xcalls %>% as.tbl %>% filter(Strike == 164)
xcalls %>% as.tbl %>% filter(Last == 164)
xcalls %>% as.tbl %>% filter(Last >0)
xcalls %>% as.tbl %>% filter(Last >0)
detach("package:dplyr", unload=TRUE)
library("dplyr", lib.loc="C:/Program Files/R/R-3.4.2/library")
xcalls %>% as.tbl %>% filter(Last >0)
xcalls %>% as.tbl %>% filter(Strike == 164)
names(xcalls)
row.names(xcalls)
xcalls = xcalls %>% rownames_to_columns(xcalls)
detach("package:tidyr", unload=TRUE)
library("tidyr", lib.loc="C:/Program Files/R/R-3.4.2/library")
xcalls$Symbol = rownames(xcalls)
xcalls %>% as.tbl
xcalls %>% as.tbl %>% filter(Strike == 164)
xoption = xcalls %>% as.tbl %>% filter(Strike == 164)
xoption
xoption$Symbol
xfullcode = xoption$Symbol
xfullcode
substr(xfullcode, 0, 3)
length(xfullcode)
library("stringr", lib.loc="C:/Program Files/R/R-3.4.2/library")
str_extract(xfullcode, '[a-z]')
nchar(xfullcode)
xn = nchar(xfullcode)
substr(xfullcode, xn-8, xn)
substr(xfullcode, xn-7, xn)
substr(xfullcode, xn-2, xn)
substr(xfullcode, xn-7, xn-3
)
as.double(xstrike_flt)/1000
xstrike_flt = substr(xfullcode, xn-2, xn)
xstrike_int = substr(xfullcode, xn-7, xn-3)
xstrike_flt
xstrike_int
as.double(xstrike_int)
as.double(xstrike_flt)/1000
xstrike = as.double(xstrike_int) + as.double(xstrike_flt)/1000
xstrike
substr(xfullcode, xn-8, xn-7)
substr(xfullcode, xn-8, xn-8)
substr(xfullcode, xn-15, xn-9)
substr(xfullcode, xn-14, xn-9)
ubstr(xfullcode, xn-14, xn-9) %>% as.Date(format='yymmdd')
substr(xfullcode, xn-14, xn-9) %>% as.Date(format='yymmdd')
substr(xfullcode, xn-14, xn-9) %>% as.Date(format='%d%b%y')
substr(xfullcode, xn-14, xn-9) %>% as.Date(format='%y%m%d')
xexpdate = substr(xfullcode, xn-14, xn-9) %>% as.Date(format='%y%m%d')
substr(xfullcode, xn, xn-15)
substr(xfullcode, 0, xn-15)
xsymb = substr(xfullcode, 0, xn-15)
c(xsymb = xsymb)
symbol_cut = c(Symbol = xsymb)
symbol_cut
symbol_cut$Symbol
symbol_cut[Symbol]
symbol_cut['Symbol']
symbol_cut %>% as.data.frame
shiny::runApp('GitHub/OptionForTarget')
source('CalcProfitSpread.R', local = T)
getwd()
setwd('C:/Users/Andreal/Documents/GitHub/OptionForTarget')
source('CalcProfitSpread.R', local = T)
print(getwd())
source('CalcProfitForSpread.R', local = T)
runApp()
#
# Функция для приложения: выгрузка страйка-премии опциона
#
#
GetStrikePremiumTable = function(symbol, expiry_date, market_price_type, opt_right){
if(!require('quantmod')) install.packages('quantmod')
# Загружаем опционную доску выбранного актива и даты экспирации;
option_chain = getOptionChain(symbol, Exp=expiry_date)
# Выбираем столбцы Примия и Страйк;
opt_rights = c("call", "put")
opt_board_n = which( opt_rights %in% opt_right)
option_chain_short = option_chain[[opt_board_n]]
# Рыночная цена - середина
if(market_price_type=="mid"){
option_chain_short$Mid = (option_chain_short$Ask + option_chain_short$Bid)/2
option_chain_short = option_chain_short[, c("Strike", "Mid", "Ask", "Bid")]
}
# Рыночная цена - цена последней сделки
if(market_price_type=="last")
option_chain_short = option_chain_short[, c("Strike", "Last", "Ask", "Bid")]
names(option_chain_short) = c("Strike", "Premium", "Ask", "Bid")
return(option_chain_short)
}
source('~/GitHub/OptionForTarget/CalcProfitForSpread.R', encoding = 'UTF-8')
CalcProfitForSpread = function(board, target, opt_type, ba_price=0, bank_rate=NULL, exp_date=NULL, atm_only=T, market_price = F){
if(!require('dplyr')) install.packages('dplyr')
if(!require('scales')) install.packages('scales')
# Проверяем наличие колонок Strike и Premium
columns_required = c('Strike', 'Premium')
columns_present = names(board)
columns_missing = setdiff(columns_required, columns_present)
if(length(columns_missing)>0)
stop(paste0("Can't find required columns in dataframe: ", columns_missing))
# Если известна цена базового актива, определяем центральный страйк и за базовую премию принимаем премию центр. страйка
# Если цена базовго актива не известна, базовая премия равна средней премии опциона в серии
if(ba_price>0)
{
atm_index = AtmStrike( board$Strike, ba_price, T )
atm_premium = board$Premium[ atm_index ]
atm_strike = AtmStrike( board$Strike, ba_price, F )
}  else {
atm_premium = mean(board$Premium, na.rm = T)
atm_index = which.min(abs(board$Premium - atm_premium))
atm_strike = board$Strike[atm_index]
}
# Если нет цены актива, текущая цена = центральный страйк
if(ba_price==0) ba_price=atm_strike
# Define numeric var for option type
# TODO: rename to callput
opt_type_num = ifelse(opt_type=="call", 1, -1)
# Select only OTM strikes for long option in streads
otm_strikes = board$Strike
otm_strikes = otm_strikes[ (opt_type_num*otm_strikes >= opt_type_num*ba_price) & (opt_type_num*otm_strikes <= opt_type_num*target)]
# Empty table for all profits
profit_table = NULL
for (strike1 in otm_strikes){  # calc profit for each pair strike1 (long) / strike2 (short)
if (market_price == F){
prem1 = board$Premium[board$Strike==strike1] # Long option premium
prem2 = board$Premium
} else {
prem1 = board$Ask[board$Strike==strike1]
prem2 = board$Bid
}
profit_df = board %>%
mutate(Strike1=strike1,
Strike2=Strike,
Prem1=prem1,
Prem2=prem2,
PremSprd=Prem1-Prem2)
# Select strikes2 only before target
profit_df = profit_df %>% filter(Strike2*opt_type_num <= target*opt_type_num)
# If target price before Strike2 (short option) then calc profit at target price, else - calc profit at Strike2 price
if(opt_type_num==1)
profit_df = profit_df %>% mutate(RealTarget = pmin(Strike2, target))
else
profit_df = profit_df %>% mutate(RealTarget = pmax(Strike2, target))
profit_df = profit_df %>%
mutate( Revenue = (RealTarget-Strike1) * opt_type_num ) %>%
mutate( Revenue = pmax(0, Revenue) ) %>%
mutate( Profit = Revenue - PremSprd ) %>%
mutate( Q =  atm_premium / PremSprd ) %>%
mutate( Profitability = Profit / PremSprd ) %>%
mutate( ROR = Q*Profit / ba_price)   # Доходность опциона относительно текущей цены базового актива (Колич * Прибыль / Цена_актива)
# Calc spread Return for a given bank rate as a budget limit
if( !is.null(bank_rate) & !is.null(exp_date) ){
exp_date = as.Date(exp_date)
exp_days = as.numeric(exp_date - Sys.Date())
exp_years = exp_days / 365
profit_df = profit_df %>% mutate( Return = (bank_rate*exp_years)/(PremSprd/ba_price)*(Revenue/ba_price)  )
# profit_at_strike$Return = percent(profit_at_strike$Return)
}
# Merge tables for various strike1 results
if(!is.null(profit_table))
profit_table = rbind(profit_table, profit_df)
else
profit_table = profit_df
}
# Оставляем страйки только до цели (после цели фин.рез всё равно 0)
profit_table = profit_table %>% filter(Q>0)
return(profit_table)
}
#UTF-8
if(!require('quantmod')) install.packages('quantmod')
require(dplyr)
require(ggplot2)
# Безрисковая ставка депозита
bank_ror = 0.045
# Задаём символ базового актива;
symbol = "QQQ"
# Задаём Цель по цене безового актива;
target = 170
# Загружаем текущую цену базового актива;
symbol_price = getQuote(symbol)$Last
symbol_price
CalcProfitForSpread = function(board, target, opt_type, ba_price=0, bank_rate=NULL, exp_date=NULL, atm_only=T, market_price = F){
if(!require('dplyr')) install.packages('dplyr')
if(!require('scales')) install.packages('scales')
# Проверяем наличие колонок Strike и Premium
columns_required = c('Strike', 'Premium')
columns_present = names(board)
columns_missing = setdiff(columns_required, columns_present)
if(length(columns_missing)>0)
stop(paste0("Can't find required columns in dataframe: ", columns_missing))
# Если известна цена базового актива, определяем центральный страйк и за базовую премию принимаем премию центр. страйка
# Если цена базовго актива не известна, базовая премия равна средней премии опциона в серии
if(ba_price>0)
{
atm_index = AtmStrike( board$Strike, ba_price, T )
atm_premium = board$Premium[ atm_index ]
atm_strike = AtmStrike( board$Strike, ba_price, F )
}  else {
atm_premium = mean(board$Premium, na.rm = T)
atm_index = which.min(abs(board$Premium - atm_premium))
atm_strike = board$Strike[atm_index]
}
# Если нет цены актива, текущая цена = центральный страйк
if(ba_price==0) ba_price=atm_strike
# Define numeric var for option type
# TODO: rename to callput
opt_type_num = ifelse(opt_type=="call", 1, -1)
# Select only OTM strikes for long option in streads
otm_strikes = board$Strike
otm_strikes = otm_strikes[ (opt_type_num*otm_strikes >= opt_type_num*ba_price) & (opt_type_num*otm_strikes <= opt_type_num*target)]
# Empty table for all profits
profit_table = NULL
for (strike1 in otm_strikes){  # calc profit for each pair strike1 (long) / strike2 (short)
if (market_price == F){
prem1 = board$Premium[board$Strike==strike1] # Long option premium
prem2 = board$Premium
} else {
prem1 = board$Ask[board$Strike==strike1]
prem2 = board$Bid
}
profit_df = board %>%
mutate(Strike1=strike1,
Strike2=Strike,
Prem1=prem1,
Prem2=prem2,
PremSprd=Prem1-Prem2)
# Select strikes2 only before target
profit_df = profit_df %>% filter(Strike2*opt_type_num <= target*opt_type_num)
# If target price before Strike2 (short option) then calc profit at target price, else - calc profit at Strike2 price
if(opt_type_num==1)
profit_df = profit_df %>% mutate(RealTarget = pmin(Strike2, target))
else
profit_df = profit_df %>% mutate(RealTarget = pmax(Strike2, target))
profit_df = profit_df %>%
mutate( Revenue = (RealTarget-Strike1) * opt_type_num ) %>%
mutate( Revenue = pmax(0, Revenue) ) %>%
mutate( Profit = Revenue - PremSprd ) %>%
mutate( Q =  atm_premium / PremSprd ) %>%
mutate( Profitability = Profit / PremSprd ) %>%
mutate( ROR = Q*Profit / ba_price)   # Доходность опциона относительно текущей цены базового актива (Колич * Прибыль / Цена_актива)
# Calc spread Return for a given bank rate as a budget limit
if( !is.null(bank_rate) & !is.null(exp_date) ){
exp_date = as.Date(exp_date)
exp_days = as.numeric(exp_date - Sys.Date())
exp_years = exp_days / 365
profit_df = profit_df %>% mutate( Return = (bank_rate*exp_years)/(PremSprd/ba_price)*(Revenue/ba_price)  )
# profit_at_strike$Return = percent(profit_at_strike$Return)
}
# Merge tables for various strike1 results
if(!is.null(profit_table))
profit_table = rbind(profit_table, profit_df)
else
profit_table = profit_df
}
# Оставляем страйки только до цели (после цели фин.рез всё равно 0)
profit_table = profit_table %>% filter(Q>0)
return(profit_table)
}
if(!require('quantmod')) install.packages('quantmod')
require(dplyr)
require(ggplot2)
# Безрисковая ставка депозита
bank_ror = 0.045
# Задаём символ базового актива;
symbol = "QQQ"
# Задаём Цель по цене безового актива;
target = 160
# Загружаем текущую цену базового актива;
symbol_price = getQuote(symbol)$Last
# Загружаем доступные даты экспирации символа (Символ);
expiry_dates = GetExpiryDates(symbol)
expiry_dates
expiry_date = expiry_dates[5]
source("CalcProfitForStrike.R", local = T, echo = F)
source('AtmStrike.R', local = T)
source('GetExpiryDates.R', local = T)
source('GetStrikePremiumTable.R', local = T)
source('CalcProfitForTargets.R', local = T)
source('CalcProfitForSpread.R', local = T)
if(!require('quantmod')) install.packages('quantmod')
require(dplyr)
require(ggplot2)
# Безрисковая ставка депозита
bank_ror = 0.045
# Задаём символ базового актива;
symbol = "QQQ"
# Задаём Цель по цене безового актива;
target = 160
# Загружаем текущую цену базового актива;
symbol_price = getQuote(symbol)$Last
expiry_dates = GetExpiryDates(symbol)
expiry_dates
expiry_date = expiry_dates[5]
# Определяем направление движения к цели
opt_rights = c("call", "put")
opt_right = ifelse(target>symbol_price, opt_rights[1], opt_rights[2])
market_price_types = c("mid", "last")
market_price_type = market_price_types[2]
option_chain_short = GetStrikePremiumTable(symbol, expiry_date, market_price_type, opt_right)
View(option_chain_short)
profit_table = CalcProfitForSpread(option_chain_short, target, opt_right, symbol_price, bank_ror, expiry_date, market_price = T)
View(profit_table)
profit_table = profit_table %>% dplyr::select(Strike1, Strike2, Return) %>%
mutate(Return = round(Return * 100, 2))
ggplot(data=profit_table, aes(x=Strike2, y=Strike1, fill=Return)) + geom_tile() +
scale_fill_gradient2(low = "white", high = "green", mid = "white", name="Return, %") +
geom_text(aes(label=Return), size=3)
profit_table = CalcProfitForSpread(option_chain_short, target, opt_right, symbol_price, bank_ror, expiry_date, market_price = F)
profit_table = profit_table %>% dplyr::select(Strike1, Strike2, Return) %>%
mutate(Return = round(Return * 100, 2))
ggplot(data=profit_table, aes(x=Strike2, y=Strike1, fill=Return)) + geom_tile() +
scale_fill_gradient2(low = "white", high = "green", mid = "white", name="Return, %") +
geom_text(aes(label=Return), size=3)
runApp()
install.packages("forecast")
library("forecast", lib.loc="C:/Program Files/R/R-3.4.2/library")
install.packages("stR")
library("stR", lib.loc="C:/Program Files/R/R-3.4.2/library")
decompose(co1)
decompose(co2)
plot(m1)
m1 = decompose(co2)
plot(m1)
m2 = stl(co2, s.window = "periodic")
plot(m2)
m2
summary(m2)
require(forecast)
Acf(wineind)
Pacf(wineind)
wineind
## Not run:
taperedacf(wineind, nsim=50)
taperedpacf(wineind, nsim=50)
acf(wineind)
stats::acf(wineind)
stats::acf(wineind)
stats::acf(wineind, type="correlation")
Acf(wineind)
stats::acf(wineind)
stats::acf(wineind, type="correlation", demean = F)
acf(lh)
acf(lh, type = "covariance")
pacf(lh)
acf(ldeaths)
acf(ldeaths, ci.type = "ma")
acf(ts.union(mdeaths, fdeaths))
ccf(mdeaths, fdeaths, ylab = "cross-correlation")
acf(presidents, na.action = na.pass)
pacf(presidents, na.action = na.pass)
require(forecast)
